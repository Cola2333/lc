# 总结一下背包问题的特征

## 背包问题总会有一个可供选择的数组 和一个上限

### 第一类问题 不可重复取
#### eg1. 570课上的背包问题 n种商品为选择数组 W为上限 这个题目比较特殊 那就是它的选择数组并不单单是n, 对于每一个n, 都有一个[w,v]与其关联, w用来对应上限 v用来对应问题所求

### 第二类问题 可重复取
#### eg2. 570课上的硬币问题 各种硬币为选择数组 要组成的钱数为上限 这个题目就是比较常规的题目 对于每个硬币, 都有一个面额与其关联, 硬币的面额用来决定上限 硬币的个数用来对应所求
#### eg3. No343_IntegerBreak n - 1个整数数为选择数组 要分割的数字n为上限 这个题目也是比较常规的题目 对于每个整数, 自己即为对应, 数值与上限关联, 整数个数对应所求 但是这个问题有一点特殊的地方 就是对于i=n时 要特殊循环 因为如果将数字分割成了n 0就不符合题意了
#### eg4. No322_CoinChange 基本与eg2一致 只是给定的金额不一定能被组成 所以对base case的赋值要注意
#### eg5. No279_PerfectSquares 小于n的完全平方数为选择数组(可理解为自己生成) n为上限 这个题目也是比较常规的题目
#### eg6. No139_WordBreak 给定的字典为选择数组 给定的字符串为上限 这个题目描述的有一点特殊 他是一个true false的题目 而且我们可以不通过在上限上删除选择数组中的元素来完成 具体如何特殊可以看代码理解
####补充 至于第二层循环是从小到大还是从大到小 其实都可以 但是如果想要一个规定的话 我觉得从小到大会比较好 因为这样不管是给定的选择还是自己生成的选择都可以先拿到选择数组中最小的 然后用i减去这个最小的使得每次都可以从离i最近的dp[j]开始
####本质 这类问题的本质就是dp[i]必然是可以通过dp[j](j < i)得到的 只是因为i比之前的j至少会多1(抽象的1 不一定是数字) 所以需要再做一次(就一次)选择把这个差值1补上 显然补上这个差值1只需做一次选择即可 将剩余的归纳到dp[j]